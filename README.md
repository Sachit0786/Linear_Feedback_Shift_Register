# Linear-Feedback-Shift-Register
A Linear Feedback Shift Register (LFSR) is a versatile and efficient method for generating pseudo-random sequences within digital systems, including FPGAs. The LFSR operates by shifting bits and introducing feedback from certain bit positions within the register, enabling it to traverse through a predictable yet seemingly random sequence of values. Due to its simplicity and high-speed operation, LFSRs are widely used in various digital applications, such as generating random data, counters, test patterns, data scrambling, and error detection.

In this Verilog implementation, we define an LFSR whose width is determined by a parameter **Num_Bits**, allowing for flexible bit-width configurations. The key feature of this design is its ability to produce a full sequence of values before repeating, i.e., it will cycle through "2^Num_Bits - 1" unique values. Once all possible combinations have been cycled through, the output signal **cycle_complete** will pulse, indicating the completion of the sequence. This pulse occurs only once after all the pseudo-random values are generated with respect to a particular **i_Seed_Data**. 
For instance, if Num_Bits is set to 5, the LFSR will generate a sequence of 31 distinct values before resetting. The output o_LFSR_Data will provide a new pseudo-random value on each clock cycle when the module is enabled.

### **KEY PARAMETERS AND SIGNALS**
**Num_Bits**: This parameter sets the width of the LFSR, determining how many bits the register will contain. It defines the range of possible output values and how long it will take before the sequence repeats.
For example, a 5-bit LFSR will generate 31 unique values before repeating (since 2^5 - 1 = 31).
**i_Clock**: The input clock signal that drives the LFSR. On each rising edge of the clock, the LFSR will shift its contents and update its value.
**i_Enable**: This input enables or disables the operation of the LFSR. When set to 1, the LFSR shifts and generates new values; when set to 0, the LFSR holds its current state.
**i_Seed_Data**: This input sets the initial value of the LFSR, effectively allowing you to control the starting point of the pseudo-random sequence. The seed value can be any non-zero number.
**o_LFSR_Data**: The current value of the LFSR is output through this signal. It updates with each clock cycle, producing a new pseudo-random number when the module is enabled.
**cycle_complete**: This output pulses high for one clock cycle when the LFSR has completed all possible combinations of values. It can be used as a trigger or flag to signal that the LFSR has cycled through its entire sequence.
**cycle_complete**: This output pulses high for one clock cycle when the LFSR has been fed with the new **i_Seed_Data** value. It can be used as a trigger or flag to signal that the LFSR has started a new cycle with a new initial value.

# **INTERNAL OPERATIONS OF LFSR**
At the core of the LFSR is a shift register where the feedback is based on a specific tap sequence. The tap sequence refers to which bit positions are used to generate the feedback value, which gets shifted into the register. These taps determine the pseudo-random nature of the LFSR. In a maximal-length LFSR, the feedback taps are chosen in such a way that the register cycles through all possible values except zero.

In the example of a 5-bit LFSR, the feedback might be generated by XOR-ing bits at certain positions, say position 5 and position 3. The resulting XOR output is then shifted into the register, while the remaining bits are shifted to the left, forming the next value in the sequence.

# **APPLICATIONS OF LFSR**
1) Random Number Generation: LFSRs are a popular method for generating pseudo-random numbers in hardware due to their simplicity and speed. They are commonly used in cryptography, games, and other applications requiring randomness.
2) Error Detection: LFSRs can be used in Cyclic Redundancy Check (CRC) algorithms to detect errors in data transmission. The shift-and-feedback mechanism can generate checksums for data blocks, which can later be used to verify the integrity of transmitted data.
3) Counters: LFSRs can serve as counters, especially in applications where non-sequential counting is preferred. They provide a lightweight alternative to traditional binary counters.
4) Test Pattern Generation: LFSRs are used to generate test patterns for verifying the operation of digital circuits. The pseudo-random nature of the output ensures a wide variety of input combinations are tested, improving the chances of identifying potential faults.
5) Data Scrambling: By feeding a data stream through an LFSR, one can scramble the data, making it difficult to reconstruct without knowing the LFSR configuration. This technique is used in secure communications and storage systems.

# **ADVANTAGES OF USING LFSR**
1) Low Hardware Overhead: LFSRs require minimal logic resources compared to other random number generators, making them suitable for FPGA and ASIC implementations.
2) High Speed: The simple shift and XOR operations in an LFSR allow for very high-speed operation, which is critical in many real-time applications.
3) Scalability: The parameterized design allows the LFSR to be easily scaled to different bit widths, providing flexibility in different applications.
4) Full-Period Sequences: A well-designed LFSR can generate a maximal-length sequence that cycles through all possible values except zero, ensuring efficient use of states.
